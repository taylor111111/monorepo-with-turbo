

# 为什么我在金融前端项目中，拒绝把业务模块做成 npm 包

在很多团队中，只要出现“多个项目复用同一块逻辑”，第一反应往往是：

> **要不要把它做成一个 npm 包？**

在通用工具库（utils、UI 组件库）场景下，这个选择通常是合理的。

但在**金融前端项目**中，我最终选择了一条不同的路径：

> **拒绝把业务模块做成 npm 包，而是放入 monorepo 内部统一维护。**

这并不是出于技术洁癖，而是基于真实工程约束做出的判断。

---

## 一、先明确：我拒绝的不是 npm，而是“用错 npm”

npm 本身并没有问题，它非常适合解决一类问题：

- 代码分发
- 版本发布
- 跨团队、跨仓库复用

我拒绝的，是**把“业务事实”和“业务规则”当作分发制品**。

---

## 二、金融业务模块和普通库的本质区别

在金融系统中，被复用的模块往往具有这些特征：

- 承载业务规则（而不仅是工具函数）
- 对合规、风控高度敏感
- 多个产品必须保持**行为一致**
- 生命周期长，变更成本高

例如：

- 风控校验逻辑
- 用户身份 / 权限判断
- 合规说明展示规则

这些模块的核心诉求不是“被很多人安装”，而是：

> **在任何地方使用时，都必须是“同一个版本的事实”。**

---

## 三、npm 在业务模块场景下的三个隐性风险

### 1️⃣ 版本漂移几乎不可避免

一旦业务模块变成 npm 包，就意味着：

- app-a 可能停留在 v1.2.0
- app-b 已经升级到 v1.4.0

即使两个版本只差一个 patch，
在金融系统中也可能意味着：

- 不同的校验逻辑
- 不一致的合规提示

这类问题**很难通过测试完全覆盖**。

---

### 2️⃣ 业务规则被“发布流程”绑架

当业务模块需要通过 npm 发布：

- 你需要维护版本号
- 你需要写 changelog
- 你需要处理兼容性

最终，团队会开始犹豫：

> “这个规则改动，要不要发一个新版本？”

而在金融场景中，很多规则的正确性是**非讨论型的**。

---

### 3️⃣ npm 会放大组织边界，而不是业务边界

npm 的天然假设是：

> 这是一个“外部依赖”。

但金融业务模块往往是：

- 同一组织内
- 同一套业务语义
- 同一责任链条

把它们做成 npm 包，反而会：

- 强化“这是别人的模块”的心理预期
- 弱化对业务一致性的责任感

---

## 四、monorepo 的核心优势：单一业务事实源

在 monorepo 中，我更关心的是：

- 所有产品是否引用的是**同一份源码**
- 业务规则是否可以**原子性修改**

monorepo 带来的不是“方便”，而是：

> **强制一致性。**

---

## 五、为什么不用 npm + workspace 混合方案？

有人会问：

> “那我在 monorepo 里 publish 私有 npm 包不就好了？”

这个方案在工程上可行，但在业务层面仍然存在问题：

- 版本号依然存在
- 发布窗口依然存在
- 回滚复杂度依然存在

它并没有解决“业务事实被版本切割”的根本问题。

---

## 六、那什么东西适合做成 npm 包？

在我的实践中，以下内容**非常适合 npm**：

- 纯工具函数
- UI 组件库（Button / Table）
- 与业务无关的基础设施封装

它们的共同点是：

> **即使版本不同，也不会改变业务结论。**

---

## 七、我的最终取舍原则

在是否使用 npm 这个问题上，我最终形成了一个简单判断标准：

> **如果一个模块的差异，可能导致业务判断不同，
> 那它就不应该被版本化分发。**

在金融系统中，这类模块应当：

- 统一维护
- 统一升级
- 统一回滚

monorepo 更符合这一目标。

---

## 八、总结

npm 是一个优秀的分发工具，
但并不是所有复用都应该被分发。

在金融前端项目中，我更愿意牺牲一些“工程自由度”，
来换取：

- 业务一致性
- 可控的演进
- 更清晰的责任边界

这是我在真实项目中，做出的一个工程取舍。
