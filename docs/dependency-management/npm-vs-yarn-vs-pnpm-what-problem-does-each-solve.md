

# npm vs yarn vs pnpm — What Problem Does Each Solve?

> 这不是一篇“工具对比”文章。  
> 这是一篇**工程问题 → 解决方案 → 依赖模型演化**的记录。

在很多面试或技术讨论中，问题常被问成：

- npm 和 yarn 有什么区别？
- pnpm 为什么更快？
- workspace 是什么？pnpm workspace 和 yarn workspace 又有什么不同？

这些问题本身并不“错”，但它们**问得太靠后了**。  
真正该问的，其实是：

> **在不同阶段的工程规模下，我们到底遇到了什么问题？**  
> **这些工具，分别解决了哪些问题，又刻意没有解决哪些？**

---

## 1. 先统一语境：我们讨论的不是「工具」，而是「依赖模型」

不论 npm / yarn / pnpm，三者都在做同一件事：

> **把一份抽象的 dependency graph（依赖图），落地成一个可运行的 node_modules 结构。**

区别在于：

- 依赖是否允许多版本并存？
- 多版本如何存储？
- 是否追求“最大兼容性”还是“最大确定性”？
- 工具是否试图帮你“兜底”错误的依赖声明？

从这个角度看，npm / yarn / pnpm 并不是竞争关系，而是**三种不同的工程取舍**。

---

## 2. npm：为「能跑起来」负责的默认方案

### npm 解决的核心问题

- JavaScript 世界需要一个 **最低门槛的依赖安装工具**
- 目标不是“优雅”，而是：
  - 不懂依赖也能跑
  - 少报错
  - 尽量不打断开发者

### npm 的依赖模型（简化理解）

- **Node.js 原生的 module resolution**
- 尽量把依赖 **拍平（hoist）** 到顶层
- 子依赖能“蹭”到就蹭

#### 真实场景示例

```
app
 ├─ depends on: lodash@2
 └─ lib-a
     └─ depends on: lodash@1
```

npm 可能会得到：

```
node_modules/
 ├─ lodash@2        ← 顶层
 └─ lib-a/
     └─ node_modules/
         └─ lodash@1
```

如果条件允许，npm 甚至可能直接只留下一个 lodash。

### npm 的取舍

**优点**

- 心智负担最低
- 老项目兼容性极强
- “总之能跑”

**代价**

- 依赖来源不透明
- 隐式依赖极多
- 版本冲突可能在运行时才暴雷

👉 npm 的设计哲学是：  
**“我先让你跑起来，工程正确性以后再说。”**

---

## 3. yarn：在 npm 之上，引入「确定性」

yarn 并没有重写 Node 的模块系统，它解决的是 npm 的两个痛点：

1. **安装结果不可预测**
2. **安装速度慢**

### yarn 做了什么

- 引入 `yarn.lock`，确保：
  - 相同 lockfile → 相同依赖树
- 更激进的 hoisting 策略
- 更稳定的安装流程

### yarn 的本质定位

> **npm-compatible，但更可控**

yarn 并没有质疑 npm 的依赖模型本身，只是让它：

- 更快
- 更稳定
- 更可复现

在依赖结构上，yarn 与 npm **本质一致**。

---

## 4. pnpm：把「依赖」当作一等公民重新建模

pnpm 是一次**明确的立场转变**。

它不再试图“帮你兜底”，而是直接说：

> **你声明了什么依赖，我就只给你什么依赖。**

### pnpm 的核心抽象

- 每一个版本，都是一个**完全独立的节点**
- `lodash@1`、`lodash@2`、`react@18` 地位完全平等
- 共享发生在 **存储层**，而不是依赖解析层

### pnpm 的依赖模型（概念图）

```
.pnpm-store/
 ├─ lodash@1
 ├─ lodash@2
 └─ react@18

node_modules/
 ├─ .pnpm/
 │   ├─ lodash@1
 │   ├─ lodash@2
 │   └─ react@18
 └─ app/
     ├─ lodash -> lodash@2
     └─ lib-a/
         └─ lodash -> lodash@1
```

### pnpm 在做什么？

- **不拍平**
- **不隐式共享**
- **不兜底错误依赖**

### pnpm 的取舍

**优点**

- 依赖来源极其清晰
- 多版本共存是“显式事实”
- 大规模 monorepo 更安全

**代价**

- node_modules 看起来“很复杂”
- 错误会更早暴露
- 对依赖声明的正确性要求更高

👉 pnpm 的态度是：  
**“工程正确性 > 心理舒适度。”**

---

## 5. Workspace：不是新东西，而是规模问题的必然产物

### Workspace 解决什么问题？

> **多个 package 之间，如何共享源码，而不是发 npm 包？**

这是一个**工程组织问题**，不是包管理器问题。

- yarn 有 workspace
- pnpm 有 workspace
- turbo / nx 并不提供 workspace

### Workspace 的本质

- 多个 package
- 一个依赖图
- 一个安装上下文

Workspace 只负责一件事：

> **让 packages 能被多个 app 同时引用，并作为“源码”存在。**

---

## 6. 为什么工程团队要「尽量统一依赖版本」？

pnpm 允许多版本并存，并不代表这是**理想状态**。

### 抽象地看

- 每一个版本 = 一个独立节点
- 每一个节点 = 一套已知问题 + 未知风险

如果你同时使用：

- lodash@1
- lodash@2

那么你需要同时承担：

- v1 的问题
- v2 的问题

### 工程实践结论

- **工具层**：允许多版本存在（pnpm 的正确性）
- **团队层**：尽量收敛到同一版本（风险控制）

pnpm 做的是 **技术上正确的事**，  
团队要做的是 **工程上理性的选择**。

---

## 7. 总结：三种工具，三种边界意识

| 工具 | 核心目标 | 设计立场 |
|----|----|----|
| npm | 能跑起来 | 容错优先 |
| yarn | 可复现 | 稳定优先 |
| pnpm | 可证明正确 | 正确性优先 |

它们并不是谁“更先进”，而是：

> **在不同工程阶段，承担了不同的责任。**

理解这一点，比背任何对比表都重要。

---

## 后记

这篇文章刻意没有讨论：

- 快不快
- CI 友不友好
- 面试答案怎么背

因为这些问题，**在你理解依赖模型之后，会自然有答案**。

工程问题，从来不是从工具开始的。
