# 依赖管理的抽象模型：以 pnpm 为例

## 一、从“包名”到“实例”的抽象跃迁

在传统的依赖管理视角中，我们习惯于以“包名”作为认知单位，例如“lodash”就是“lodash”。这种直觉认为包名本身即是最小的工程单元。然而，实际情况更为复杂：一个包名在不同版本下可能表现出截然不同的行为和接口。因而，从抽象层面看，真正的最小、不可再分的工程单元是“package@version”，即特定版本的包实例。比如 `lodash@1`、`lodash@2`、`react@18`，它们在抽象层级上是等价的节点，都是独立的依赖实体。

## 二、pnpm 的核心立场：不做未经证明的合并

pnpm 设计的核心原则是避免对依赖进行未经验证的扁平化合并。传统的扁平化 node_modules 结构虽然看似简洁，但容易隐藏版本冲突和不兼容问题。pnpm 选择在依赖语义确定一致时才共享依赖，确保每个依赖实例的完整性和独立性。换句话说，pnpm 不是激进地追求扁平化，而是精确地反映依赖关系，避免潜在风险。

## 三、为什么 pnpm 看起来“树状发散”，但实际上更安全

pnpm 的依赖结构呈现出树状发散的形态，源自于真实的依赖图。每个依赖实例都被明确地表示和隔离，避免了隐式依赖和幽灵依赖的问题。这种结构的复杂性并非 pnpm 引入，而是工程本身依赖关系复杂性的自然反映。通过展示真实的依赖树，pnpm 帮助开发者更清晰地理解和控制依赖状态，从而提升整体安全性和可维护性。

## 四、工具层 vs 团队层：谁该为复杂性负责

在依赖管理中，必须明确工具层与团队层的责任分界。工具层（如 pnpm）负责忠实表达依赖事实，不对依赖版本做价值判断，不隐瞒复杂性；而团队层则需要通过工程规范主动收敛版本，控制复杂度。简言之，工具负责不撒谎，团队负责不让事情失控。只有两者协同，才能有效管理依赖复杂性。

## 五、为什么团队应当尽量统一依赖版本

每一个依赖版本都代表一套独立的解决方案和一组独立的缺陷。当项目同时使用多个版本（如 v1 和 v2）时，等同于同时维护多个问题集，增加了维护成本和风险。版本数量的增加往往导致维护成本呈线性甚至指数级增长。因此，团队应当尽量统一依赖版本，减少版本数量，从而降低风险和复杂度，实现更可控的工程治理。

## 六、推荐的工程实践策略

为实现依赖版本的有效管理，推荐以下实践策略：

- 新业务强制使用主版本，避免引入多版本依赖
- 老业务逐步迁移到统一版本，减少历史包袱
- 通过 lint 和 CI 工具阻止无意间引入新的版本

这些策略属于工程治理范畴，而非单纯依赖工具能力。团队需要主动制定和执行规范，确保依赖版本的可控性。

## 七、小结

pnpm 通过精确表达依赖关系，解决了传统扁平化带来的隐式依赖和版本冲突问题。它刻意避免未经验证的合并，保证依赖实例的独立性和安全性。然而，pnpm 并未解决依赖版本多样性带来的复杂性，这仍需团队通过规范和治理来承担。最终，依赖管理的责任在于团队，工具只是提供真实、透明的基础设施。
