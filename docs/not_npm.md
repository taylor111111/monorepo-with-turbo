

# 为什么 domain / widgets 不做成 npm 包

在这个仓库中，`domain-*` 与 `widgets/*` 并 **没有** 被发布为独立的 npm package。

这不是“偷懒”，而是一个**有意为之、与金融业务特性强相关的工程决策**。

本文记录：**为什么不用 npm，是更理性的选择。**

---

## 一、先说结论

> **domain 与 widgets 属于“共享业务能力”，而不是“可独立分发的产品”。**

npm 包机制解决的是「代码分发」问题，
而 domain / widgets 面对的是「**业务一致性**」问题。

二者关注点不同。

---

## 二、npm 包机制解决的是什么问题

npm 非常适合以下场景：

- 通用工具库（lodash / date-fns）
- 技术基础设施（react / axios）
- 与业务无关或弱相关的能力

它的核心假设是：

- 使用方彼此独立
- 升级可以渐进
- 版本差异是可接受的

这些假设，在金融业务模块中**通常不成立**。

---

## 三、domain / widgets 的本质不同

### 1️⃣ domain：业务事实与规则

domain 描述的是：

- 用户、账户、风控、授信等业务事实
- 必须在所有产品中保持一致的规则

**domain 的核心要求不是“可升级”，而是“不可分歧”。**

如果两个产品：

- 使用了不同版本的风控规则
- 使用了不同版本的权限判断

结果不是“体验不一致”，而是**业务风险**。

---

### 2️⃣ widgets：可嵌入业务场景

widgets 封装的是：

- 带 UI 的业务场景
- 合规提示、风险说明、PV 聊天等

widgets 的问题不在于“能不能复用”，
而在于：

> **是否允许多个版本同时存在？**

在金融系统中，答案通常是：**不允许**。

---

## 四、为什么 npm 在这里反而是负担

### ❌ 1. 版本分叉不可接受

npm 的版本机制天然允许：

- app-A 用 v1.2.0
- app-B 用 v1.3.1

在金融系统中，这往往意味着：

- 行为不一致
- 规则不可审计
- 风险难以追踪

---

### ❌ 2. 发布节奏与业务节奏冲突

npm 包要求：

- 打版本
- 发包
- 升级依赖

而金融业务中：

- 规则调整频繁
- 多产品需要**同时生效**

发布流程会变成**额外风险源**。

---

### ❌ 3. “形式上的解耦”，实际上的失控

npm 给人一种错觉：

> “我们已经解耦了”

但实际上：

- 规则仍然强耦合
- 只是被版本号隐藏了

这种“延迟暴露”的问题，在金融系统里代价极高。

---

## 五、monorepo 的优势正好对齐这些痛点

在 monorepo 中：

- domain / widgets 与 app **共存但分层**
- 修改规则 → 所有依赖方立刻可见
- 没有版本漂移
- 没有发布窗口

这使得：

> **一致性优先于独立性**

而这正是金融系统真正需要的属性。

---

## 六、这并不是“永远不用 npm”

需要强调的是：

- ❌ 不是反对 npm
- ❌ 不是否认模块化

而是：

> **在“业务一致性优先”的场景下，不滥用 npm。**

如果某个模块：

- 业务语义弱
- 升级可渐进
- 版本差异可容忍

那么它**完全可以**被抽离成 npm 包。

---

## 七、一句总结

> **npm 适合分发“技术能力”，
> monorepo 更适合承载“业务真相”。**

domain 与 widgets 属于后者。

因此，在这个仓库中：

- 它们不被发布
- 不被版本化
- 不被“解耦成假象”

而是被明确地、清晰地放在一起，
以换取业务的一致性与可控性。
