

# PvChat Widget — 设计决策记录（DECISIONS）

本文档用于记录 **PvChat 被设计为 widget 的核心决策背景**。

目标不是解释“怎么用”，而是回答：

> **为什么 PvChat 要这样设计，而不是其他看似更简单的方案？**

这些决策一旦被遗忘，组件往往会在长期演进中被“慢慢改坏”。

---

## 1. 为什么 PvChat 是 widget，而不是 page / app

### 背景

在金融产品中，“PV / 客服沟通”通常具备以下特征：

- 是一个 **完整但局部的业务场景**
- 会被多个产品 / 多个页面复用
- 自身不拥有路由
- 自身不决定产品流程

因此：

> **PvChat 的职责是“承载沟通这个场景”，而不是“定义产品结构”。**

---

### 为什么不是 page

如果把 PvChat 设计成 page：

- 会被路由绑定
- 难以嵌入其他页面
- 不同产品很容易 fork 多个版本

这会导致：

- UI 分叉
- 行为漂移
- 维护成本指数上升

---

### 为什么不是 app / 微前端

PvChat：

- 不拥有完整生命周期
- 不负责产品级状态
- 不适合作为独立部署单元

将其做成 app 或微前端：

- 复杂度过高
- 与实际业务规模不匹配

---

## 2. 为什么必须使用 adapter，而不是在内部 fetch

### 核心现实：金融产品一定存在环境差异

不同产品之间，往往存在：

- 不同鉴权方式
- 不同 API 域名
- 不同 PV 分配逻辑
- 不同埋点 / 合规 / 审计要求

如果这些差异被写进组件内部：

- 组件会迅速膨胀
- if / else 不可避免
- 组件将不可复用

---

### adapter 的职责

adapter 用于：

- 注入运行环境差异
- 隔离鉴权 / 网络 / 埋点
- 保证 PvChat 本体只关注“场景本身”

PvChat 本体应当：

- 不知道 token 从哪来
- 不知道 API 在哪里
- 不知道埋点如何上报

---

## 3. 为什么 PvChat 不直接依赖 domain

### 原则

- widget **可以消费 domain**
- widget **不应该反向绑定 domain 实现细节**

原因：

- domain 描述的是“业务事实与规则”
- PvChat 描述的是“沟通场景”

二者关注点不同，生命周期不同。

---

### 实际策略

- 如果存在稳定的沟通规则 / 合规限制，应放入 domain
- PvChat 通过 adapter 或 props 使用这些规则
- 避免在 widget 内部复制业务判断

---

## 4. 哪些能力被刻意排除在 PvChat 之外

以下能力 **刻意不放入 PvChat**：

- 路由控制
- 页面布局
- 用户身份获取
- 全局状态管理
- 产品级流程编排

原因很简单：

> **一旦引入这些能力，PvChat 将不再是 widget。**

---

## 5. 允许存在的复杂度，应该放在哪里

| 复杂度类型 | 所属位置 |
|----------|----------|
| 鉴权 / token | app / adapter |
| 网络请求 | adapter |
| 合规 / 埋点 | adapter |
| 业务规则 | domain |
| UI / 交互 | PvChat widget |

这是一条**长期约束**，而不是短期实现技巧。

---

## 6. 最重要的一句话（维护者须知）

> **如果你觉得需要在 PvChat 内部加入大量 if / else 来适配不同产品，
> 那说明设计边界已经被破坏，请先停下来重新审视。**

PvChat 的稳定性，来自于：

- 明确的职责
- 克制的能力边界
- 对 adapter 层的尊重

---

## 7. 文档目的

本文件的存在，是为了：

- 防止未来误用 PvChat
- 帮助新成员理解设计初衷
- 在架构退化之前，提供明确的“刹车点”

如果你在修改 PvChat 前产生犹豫，请先阅读此文档。
